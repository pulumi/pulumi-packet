// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package packet

import (
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// Provides a Packet device resource. This can be used to create,
// modify, and delete devices.
// 
// > **Note:** All arguments including the root_password and user_data will be stored in
//  the raw state as plain-text.
// [Read more about sensitive data in state](https://www.terraform.io/docs/state/sensitive-data.html).
type Device struct {
	s *pulumi.ResourceState
}

// NewDevice registers a new resource with the given unique name, arguments, and options.
func NewDevice(ctx *pulumi.Context,
	name string, args *DeviceArgs, opts ...pulumi.ResourceOpt) (*Device, error) {
	if args == nil || args.BillingCycle == nil {
		return nil, errors.New("missing required argument 'BillingCycle'")
	}
	if args == nil || args.Facilities == nil {
		return nil, errors.New("missing required argument 'Facilities'")
	}
	if args == nil || args.Hostname == nil {
		return nil, errors.New("missing required argument 'Hostname'")
	}
	if args == nil || args.OperatingSystem == nil {
		return nil, errors.New("missing required argument 'OperatingSystem'")
	}
	if args == nil || args.Plan == nil {
		return nil, errors.New("missing required argument 'Plan'")
	}
	if args == nil || args.ProjectId == nil {
		return nil, errors.New("missing required argument 'ProjectId'")
	}
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["alwaysPxe"] = nil
		inputs["billingCycle"] = nil
		inputs["description"] = nil
		inputs["facilities"] = nil
		inputs["hardwareReservationId"] = nil
		inputs["hostname"] = nil
		inputs["ipAddressTypes"] = nil
		inputs["ipxeScriptUrl"] = nil
		inputs["networkType"] = nil
		inputs["operatingSystem"] = nil
		inputs["plan"] = nil
		inputs["projectId"] = nil
		inputs["projectSshKeyIds"] = nil
		inputs["publicIpv4SubnetSize"] = nil
		inputs["storage"] = nil
		inputs["tags"] = nil
		inputs["userData"] = nil
	} else {
		inputs["alwaysPxe"] = args.AlwaysPxe
		inputs["billingCycle"] = args.BillingCycle
		inputs["description"] = args.Description
		inputs["facilities"] = args.Facilities
		inputs["hardwareReservationId"] = args.HardwareReservationId
		inputs["hostname"] = args.Hostname
		inputs["ipAddressTypes"] = args.IpAddressTypes
		inputs["ipxeScriptUrl"] = args.IpxeScriptUrl
		inputs["networkType"] = args.NetworkType
		inputs["operatingSystem"] = args.OperatingSystem
		inputs["plan"] = args.Plan
		inputs["projectId"] = args.ProjectId
		inputs["projectSshKeyIds"] = args.ProjectSshKeyIds
		inputs["publicIpv4SubnetSize"] = args.PublicIpv4SubnetSize
		inputs["storage"] = args.Storage
		inputs["tags"] = args.Tags
		inputs["userData"] = args.UserData
	}
	inputs["accessPrivateIpv4"] = nil
	inputs["accessPublicIpv4"] = nil
	inputs["accessPublicIpv6"] = nil
	inputs["created"] = nil
	inputs["deployedFacility"] = nil
	inputs["locked"] = nil
	inputs["networks"] = nil
	inputs["ports"] = nil
	inputs["rootPassword"] = nil
	inputs["sshKeyIds"] = nil
	inputs["state"] = nil
	inputs["updated"] = nil
	s, err := ctx.RegisterResource("packet:index/device:Device", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &Device{s: s}, nil
}

// GetDevice gets an existing Device resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDevice(ctx *pulumi.Context,
	name string, id pulumi.ID, state *DeviceState, opts ...pulumi.ResourceOpt) (*Device, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["accessPrivateIpv4"] = state.AccessPrivateIpv4
		inputs["accessPublicIpv4"] = state.AccessPublicIpv4
		inputs["accessPublicIpv6"] = state.AccessPublicIpv6
		inputs["alwaysPxe"] = state.AlwaysPxe
		inputs["billingCycle"] = state.BillingCycle
		inputs["created"] = state.Created
		inputs["deployedFacility"] = state.DeployedFacility
		inputs["description"] = state.Description
		inputs["facilities"] = state.Facilities
		inputs["hardwareReservationId"] = state.HardwareReservationId
		inputs["hostname"] = state.Hostname
		inputs["ipAddressTypes"] = state.IpAddressTypes
		inputs["ipxeScriptUrl"] = state.IpxeScriptUrl
		inputs["locked"] = state.Locked
		inputs["networks"] = state.Networks
		inputs["networkType"] = state.NetworkType
		inputs["operatingSystem"] = state.OperatingSystem
		inputs["plan"] = state.Plan
		inputs["ports"] = state.Ports
		inputs["projectId"] = state.ProjectId
		inputs["projectSshKeyIds"] = state.ProjectSshKeyIds
		inputs["publicIpv4SubnetSize"] = state.PublicIpv4SubnetSize
		inputs["rootPassword"] = state.RootPassword
		inputs["sshKeyIds"] = state.SshKeyIds
		inputs["state"] = state.State
		inputs["storage"] = state.Storage
		inputs["tags"] = state.Tags
		inputs["updated"] = state.Updated
		inputs["userData"] = state.UserData
	}
	s, err := ctx.ReadResource("packet:index/device:Device", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &Device{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *Device) URN() *pulumi.URNOutput {
	return r.s.URN()
}

// ID is this resource's unique identifier assigned by its provider.
func (r *Device) ID() *pulumi.IDOutput {
	return r.s.ID()
}

// The ipv4 private IP assigned to the device
func (r *Device) AccessPrivateIpv4() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["accessPrivateIpv4"])
}

// The ipv4 maintenance IP assigned to the device
func (r *Device) AccessPublicIpv4() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["accessPublicIpv4"])
}

// The ipv6 maintenance IP assigned to the device
func (r *Device) AccessPublicIpv6() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["accessPublicIpv6"])
}

// If true, a device with OS `custom_ipxe` will
// continue to boot via iPXE on reboots.
func (r *Device) AlwaysPxe() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["alwaysPxe"])
}

// monthly or hourly
func (r *Device) BillingCycle() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["billingCycle"])
}

// The timestamp for when the device was created
func (r *Device) Created() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["created"])
}

// The facility where the device is deployed.
func (r *Device) DeployedFacility() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["deployedFacility"])
}

// Description string for the device
func (r *Device) Description() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["description"])
}

// List of facility codes with deployment preferences. Packet API will go through the list and will deploy your device to first facility with free capacity. List items must be facility codes or `any` (a wildcard). To find the facility code, visit [Facilities API docs](https://www.packet.com/developers/api/#facilities), set your API auth token in the top of the page and see JSON from the API response.
func (r *Device) Facilities() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["facilities"])
}

// The id of hardware reservation where you want this device deployed, or `next-available` if you want to pick your next available reservation automatically.
func (r *Device) HardwareReservationId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["hardwareReservationId"])
}

// The device name
func (r *Device) Hostname() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["hostname"])
}

// A set containing one or more of [`private_ipv4`, `public_ipv4`, `public_ipv6`]. It specifies which IP address types a new device should obtain. If omitted, a created device will obtain all 3 addresses. If you only want private IPv4 address for the new device, pass [`private_ipv4`].
func (r *Device) IpAddressTypes() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["ipAddressTypes"])
}

// URL pointing to a hosted iPXE script. More
// information is in the
// [Custom iPXE](https://support.packet.com/kb/articles/custom-ipxe)
// doc.
func (r *Device) IpxeScriptUrl() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["ipxeScriptUrl"])
}

// Whether the device is locked
func (r *Device) Locked() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["locked"])
}

// The device's private and public IP (v4 and v6) network details. When a device is run without any special network configuration, it will have 3 networks: 
// * Public IPv4 at `packet_device.name.network.0`
// * IPv6 at `packet_device.name.network.1`
// * Private IPv4 at `packet_device.name.network.2`
// Elastic addresses then stack by type - an assigned public IPv4 will go after the management public IPv4 (to index 1), and will then shift the indices of the IPv6 and private IPv4. Assigned private IPv4 will go after the management private IPv4 (to the end of the network list).
// The fields of the network attributes are:
func (r *Device) Networks() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["networks"])
}

// Network type of device, used for [Layer 2 networking](https://support.packet.com/kb/articles/layer-2-overview). Allowed values are `layer3`, `hybrid`, `layer2-individual` and `layer2-bonded`. If you keep it empty, Terraform will not handle the network type of the device.
func (r *Device) NetworkType() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["networkType"])
}

// The operating system slug. To find the slug, or visit [Operating Systems API docs](https://www.packet.com/developers/api/#operatingsystems), set your API auth token in the top of the page and see JSON from the API response.
func (r *Device) OperatingSystem() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["operatingSystem"])
}

// The device plan slug. To find the plan slug, visit [Device plans API docs](https://www.packet.com/developers/api/#plans), set your auth token in the top of the page and see JSON from the API response.
func (r *Device) Plan() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["plan"])
}

func (r *Device) Ports() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["ports"])
}

// The id of the project in which to create the device
func (r *Device) ProjectId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["projectId"])
}

// Array of IDs of the project SSH keys which should be added to the device. If you omit this, SSH keys of all the members of the parent project will be added to the device. If you specify this array, only the listed project SSH keys will be added. Project SSH keys can be created with the [packet_project_ssh_key][packet_project_ssh_key.html] resource.
func (r *Device) ProjectSshKeyIds() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["projectSshKeyIds"])
}

// Size of allocated subnet, more
// information is in the
// [Custom Subnet Size](https://support.packet.com/kb/articles/custom-subnet-size) doc.
func (r *Device) PublicIpv4SubnetSize() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["publicIpv4SubnetSize"])
}

// Root password to the server (disabled after 24 hours)
func (r *Device) RootPassword() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["rootPassword"])
}

// List of IDs of SSH keys deployed in the device, can be both user and project SSH keys
func (r *Device) SshKeyIds() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["sshKeyIds"])
}

// The status of the device
func (r *Device) State() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["state"])
}

// JSON for custom partitioning. Only usable on reserved hardware. More information in in the [Custom Partitioning and RAID](https://support.packet.com/kb/articles/custom-partitioning-raid) doc.
func (r *Device) Storage() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["storage"])
}

// Tags attached to the device
func (r *Device) Tags() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["tags"])
}

// The timestamp for the last time the device was updated
func (r *Device) Updated() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["updated"])
}

// A string of the desired User Data for the device.
func (r *Device) UserData() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["userData"])
}

// Input properties used for looking up and filtering Device resources.
type DeviceState struct {
	// The ipv4 private IP assigned to the device
	AccessPrivateIpv4 interface{}
	// The ipv4 maintenance IP assigned to the device
	AccessPublicIpv4 interface{}
	// The ipv6 maintenance IP assigned to the device
	AccessPublicIpv6 interface{}
	// If true, a device with OS `custom_ipxe` will
	// continue to boot via iPXE on reboots.
	AlwaysPxe interface{}
	// monthly or hourly
	BillingCycle interface{}
	// The timestamp for when the device was created
	Created interface{}
	// The facility where the device is deployed.
	DeployedFacility interface{}
	// Description string for the device
	Description interface{}
	// List of facility codes with deployment preferences. Packet API will go through the list and will deploy your device to first facility with free capacity. List items must be facility codes or `any` (a wildcard). To find the facility code, visit [Facilities API docs](https://www.packet.com/developers/api/#facilities), set your API auth token in the top of the page and see JSON from the API response.
	Facilities interface{}
	// The id of hardware reservation where you want this device deployed, or `next-available` if you want to pick your next available reservation automatically.
	HardwareReservationId interface{}
	// The device name
	Hostname interface{}
	// A set containing one or more of [`private_ipv4`, `public_ipv4`, `public_ipv6`]. It specifies which IP address types a new device should obtain. If omitted, a created device will obtain all 3 addresses. If you only want private IPv4 address for the new device, pass [`private_ipv4`].
	IpAddressTypes interface{}
	// URL pointing to a hosted iPXE script. More
	// information is in the
	// [Custom iPXE](https://support.packet.com/kb/articles/custom-ipxe)
	// doc.
	IpxeScriptUrl interface{}
	// Whether the device is locked
	Locked interface{}
	// The device's private and public IP (v4 and v6) network details. When a device is run without any special network configuration, it will have 3 networks: 
	// * Public IPv4 at `packet_device.name.network.0`
	// * IPv6 at `packet_device.name.network.1`
	// * Private IPv4 at `packet_device.name.network.2`
	// Elastic addresses then stack by type - an assigned public IPv4 will go after the management public IPv4 (to index 1), and will then shift the indices of the IPv6 and private IPv4. Assigned private IPv4 will go after the management private IPv4 (to the end of the network list).
	// The fields of the network attributes are:
	Networks interface{}
	// Network type of device, used for [Layer 2 networking](https://support.packet.com/kb/articles/layer-2-overview). Allowed values are `layer3`, `hybrid`, `layer2-individual` and `layer2-bonded`. If you keep it empty, Terraform will not handle the network type of the device.
	NetworkType interface{}
	// The operating system slug. To find the slug, or visit [Operating Systems API docs](https://www.packet.com/developers/api/#operatingsystems), set your API auth token in the top of the page and see JSON from the API response.
	OperatingSystem interface{}
	// The device plan slug. To find the plan slug, visit [Device plans API docs](https://www.packet.com/developers/api/#plans), set your auth token in the top of the page and see JSON from the API response.
	Plan interface{}
	Ports interface{}
	// The id of the project in which to create the device
	ProjectId interface{}
	// Array of IDs of the project SSH keys which should be added to the device. If you omit this, SSH keys of all the members of the parent project will be added to the device. If you specify this array, only the listed project SSH keys will be added. Project SSH keys can be created with the [packet_project_ssh_key][packet_project_ssh_key.html] resource.
	ProjectSshKeyIds interface{}
	// Size of allocated subnet, more
	// information is in the
	// [Custom Subnet Size](https://support.packet.com/kb/articles/custom-subnet-size) doc.
	PublicIpv4SubnetSize interface{}
	// Root password to the server (disabled after 24 hours)
	RootPassword interface{}
	// List of IDs of SSH keys deployed in the device, can be both user and project SSH keys
	SshKeyIds interface{}
	// The status of the device
	State interface{}
	// JSON for custom partitioning. Only usable on reserved hardware. More information in in the [Custom Partitioning and RAID](https://support.packet.com/kb/articles/custom-partitioning-raid) doc.
	Storage interface{}
	// Tags attached to the device
	Tags interface{}
	// The timestamp for the last time the device was updated
	Updated interface{}
	// A string of the desired User Data for the device.
	UserData interface{}
}

// The set of arguments for constructing a Device resource.
type DeviceArgs struct {
	// If true, a device with OS `custom_ipxe` will
	// continue to boot via iPXE on reboots.
	AlwaysPxe interface{}
	// monthly or hourly
	BillingCycle interface{}
	// Description string for the device
	Description interface{}
	// List of facility codes with deployment preferences. Packet API will go through the list and will deploy your device to first facility with free capacity. List items must be facility codes or `any` (a wildcard). To find the facility code, visit [Facilities API docs](https://www.packet.com/developers/api/#facilities), set your API auth token in the top of the page and see JSON from the API response.
	Facilities interface{}
	// The id of hardware reservation where you want this device deployed, or `next-available` if you want to pick your next available reservation automatically.
	HardwareReservationId interface{}
	// The device name
	Hostname interface{}
	// A set containing one or more of [`private_ipv4`, `public_ipv4`, `public_ipv6`]. It specifies which IP address types a new device should obtain. If omitted, a created device will obtain all 3 addresses. If you only want private IPv4 address for the new device, pass [`private_ipv4`].
	IpAddressTypes interface{}
	// URL pointing to a hosted iPXE script. More
	// information is in the
	// [Custom iPXE](https://support.packet.com/kb/articles/custom-ipxe)
	// doc.
	IpxeScriptUrl interface{}
	// Network type of device, used for [Layer 2 networking](https://support.packet.com/kb/articles/layer-2-overview). Allowed values are `layer3`, `hybrid`, `layer2-individual` and `layer2-bonded`. If you keep it empty, Terraform will not handle the network type of the device.
	NetworkType interface{}
	// The operating system slug. To find the slug, or visit [Operating Systems API docs](https://www.packet.com/developers/api/#operatingsystems), set your API auth token in the top of the page and see JSON from the API response.
	OperatingSystem interface{}
	// The device plan slug. To find the plan slug, visit [Device plans API docs](https://www.packet.com/developers/api/#plans), set your auth token in the top of the page and see JSON from the API response.
	Plan interface{}
	// The id of the project in which to create the device
	ProjectId interface{}
	// Array of IDs of the project SSH keys which should be added to the device. If you omit this, SSH keys of all the members of the parent project will be added to the device. If you specify this array, only the listed project SSH keys will be added. Project SSH keys can be created with the [packet_project_ssh_key][packet_project_ssh_key.html] resource.
	ProjectSshKeyIds interface{}
	// Size of allocated subnet, more
	// information is in the
	// [Custom Subnet Size](https://support.packet.com/kb/articles/custom-subnet-size) doc.
	PublicIpv4SubnetSize interface{}
	// JSON for custom partitioning. Only usable on reserved hardware. More information in in the [Custom Partitioning and RAID](https://support.packet.com/kb/articles/custom-partitioning-raid) doc.
	Storage interface{}
	// Tags attached to the device
	Tags interface{}
	// A string of the desired User Data for the device.
	UserData interface{}
}
